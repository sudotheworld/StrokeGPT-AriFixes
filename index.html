<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Handy AI Chat</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

        :root {
            --background-darker: #21222C;
            --background: #282a36;
            --background-lighter: #343746;
            --foreground: #f8f8f2;
            --comment: #6272a4;
            --cyan: #8be9fd;
            --purple: #bd93f9;
            --pink: #ff79c6;
            --red: #ff5555;
            --yellow: #f1fa8c;
            --shadow: rgba(0, 0, 0, 0.2);
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-darker);
            color: var(--foreground);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: grid;
            grid-template-columns: 1fr 320px;
            transition: grid-template-columns 0.35s ease-in-out;
        }
        body.sidebar-collapsed { grid-template-columns: 1fr 0px; }

        #splash-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10000; transition: opacity 1s ease-out; opacity: 1; }
        #splash-screen.hidden { opacity: 0; pointer-events: none; }
        #splash-screen img { max-width: 90%; max-height: 70%; object-fit: contain; border-radius: 16px; }
        #splash-screen p { margin-top: 20px; font-size: 2rem; color: #fff; text-shadow: 0 0 10px var(--pink), 0 0 20px var(--pink); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        #main-area { flex-grow: 1; display: flex; flex-direction: column; height: 100%; background-color: var(--background); overflow: hidden; }
        
        #sidebar { padding: 20px; background-color: var(--background-darker); overflow-y: auto; overflow-x: hidden; display: flex; flex-direction: column; gap: 20px; border-left: 1px solid var(--background-lighter); }
       
        #top-bar { padding: 10px 20px; background-color: var(--background); border-bottom: 1px solid var(--background-lighter); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; position: relative; }
        #toggle-sidebar-btn { position: absolute; top: 50%; right: 20px; transform: translateY(-50%); background: var(--background-lighter); border: none; color: var(--foreground); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: transform 0.3s ease-in-out, background-color 0.2s ease; font-size: 1.2em; display: flex; align-items: center; justify-content: center; }
        #toggle-sidebar-btn:hover { background-color: var(--comment); }
        body.sidebar-collapsed #toggle-sidebar-btn { transform: translateY(-50%) rotate(180deg); }

        #top-bar h1 { margin: 0; font-size: 1.5rem; color: var(--cyan); font-weight: 600; letter-spacing: 1px; text-shadow: 0 0 5px rgba(139, 233, 253, 0.4); }
        #top-bar .top-bar-info { display: flex; align-items: center; gap: 15px; margin-right: 45px; }
        #mood-display, #edging-timer { background-color: var(--background-lighter); padding: 6px 12px; border-radius: 8px; font-size: 0.9em; }
        #edging-timer { color: var(--yellow); font-weight: 600; }

        #chat-view { flex-grow: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; }
        #bottom-input-area { padding: 20px; border-top: 1px solid var(--background-lighter); background-color: var(--background); flex-shrink: 0; }

        .chat-message-container { display: flex; align-items: flex-end; gap: 10px; margin-bottom: 15px; max-width: 85%; animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .chat-pfp { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; flex-shrink: 0; }
        .message-content { display: flex; flex-direction: column; }
        .message-bubble { padding: 12px 16px; border-radius: 18px; line-height: 1.5; word-wrap: break-word; }
        .message-bubble pre { font-family: 'Courier New', Courier, monospace; font-size: 0.9em; text-align: left; white-space: pre; }
        
        .bot-bubble { align-self: flex-start; }
        .bot-bubble .message-bubble { background-color: var(--background-lighter); border-top-left-radius: 4px; }
        .bot-bubble .speaker-name { align-self: flex-start; }

        .user-bubble { align-self: flex-end; }
        .user-bubble .message-bubble { background-color: var(--comment); color: var(--foreground); border-top-right-radius: 4px; }
        
        .speaker-name { font-size: 0.8em; margin-bottom: 4px; color: var(--purple); font-weight: 600; }
        .user-bubble .speaker-name { align-self: flex-end; }
        
        #visualizer-box { height: 40px; background-color: var(--background-darker); border-radius: 8px; margin-bottom: 15px; padding: 5px; }
        .setting-section { border-radius: 12px; padding: 15px; background-color: var(--background); box-shadow: 0 4px 12px var(--shadow); }
        .setting-section h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: var(--cyan); border-bottom: 1px solid var(--background-lighter); padding-bottom: 10px; }
        
        .my-button { padding: 10px 16px; border: none; background-color: var(--comment); color: var(--foreground); border-radius: 8px; cursor: pointer; transition: all 0.2s ease; font-size: 1em; font-weight: 600; width: 100%; box-shadow: 0 2px 4px var(--shadow); }
        .my-button:hover { background-color: #798dcc; transform: translateY(-2px); box-shadow: 0 4px 8px var(--shadow); }
        .my-button:active { transform: translateY(0); box-shadow: 0 2px 4px var(--shadow); }
        .sidebar-button.edging { background-color: var(--yellow); color: var(--background); }
        .sidebar-button.edging:hover { background-color: #f7ffae; }
        .sidebar-button.milking { background-color: var(--pink); }
        .sidebar-button.milking:hover { background-color: #ff92d0; }
        .sidebar-button.stop { background-color: var(--red); }
        .sidebar-button.stop:hover { background-color: #ff6e6e; }

        .input-text, .select-box, input[type="number"] { padding: 10px; border: 1px solid var(--background-lighter); background-color: var(--background-lighter); color: var(--foreground); border-radius: 8px; font-size: 1em; width: 100%; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .input-text:focus, .select-box:focus, input[type="number"]:focus { outline: none; border-color: var(--purple); box-shadow: 0 0 0 3px rgba(189, 147, 249, 0.3); }

        #message-input-line { display: flex; gap: 10px; align-items: center; }
        #message-input-line .my-button { width: auto; flex-shrink: 0; }
        #message-input-line .input-text { flex-grow: 1; }

        .audio-toggle-line { display: flex; align-items: center; gap: 8px; padding-top: 10px; }

        #status-text { margin-top: 15px; font-size: 0.9em; text-align: center; color: var(--purple); }
        #setup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 9999; color: var(--foreground); }
        #setup-box { text-align: center; background-color: var(--background); padding: 30px; border-radius: 12px; border: 1px solid var(--background-lighter); box-shadow: 0 8px 32px var(--shadow); }
        #setup-box h2 { color: var(--cyan); margin-top: 0; }
        #setup-box button { margin-top: 15px; }
        .slider-container { margin: 15px 0; }
        
        .timing-row { display: flex; align-items: center; gap: 5px; margin-bottom: 8px; }
        .timing-row label { flex-basis: 50px; font-size: 0.9em; }
        .timing-row input { flex-grow: 1; width: 40px; }
        .timing-row span { padding: 0 5px; }

        .typing-dots span { display: inline-block; animation: blink 1.4s infinite both; font-size: 1.5em; line-height: 0; }
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink { 0% { opacity: 0.2; } 20% { opacity: 1; } 100% { opacity: 0.2; } }

        #easter-egg-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #0f0; font-family: 'Courier New', monospace; font-size: 1.5em; display: none; align-items: center; justify-content: center; z-index: 10001; opacity: 0; transition: opacity 1s ease-in-out; text-align: center; }

    </style>
</head>
<body>
    <div id="splash-screen">
        <img src="/static/splash.jpg" alt="StrokeGPT">
        <p>Press Enter to Begin</p>
    </div>
    <div id="main-area">
        <div id="top-bar">
            <h1>StrokeGPT</h1>
            <div class="top-bar-info">
                <div id="edging-timer" style="display: none;">00:00</div>
                <div id="mood-display">Mood: ...</div>
            </div>
            <button id="toggle-sidebar-btn">&laquo;</button>
        </div>
        <div id="chat-view">
            <div id="chat-messages-container">
                <div id="typing-indicator" class="chat-message-container bot-bubble" style="display: none;">
                    <img class="chat-pfp" id="typing-indicator-pfp" src="/static/default-pfp.png" alt="pfp">
                    <div class="message-content">
                        <p class="speaker-name">BOT</p>
                        <p class="message-bubble typing-dots"><span>.</span><span>.</span><span>.</span></p>
                    </div>
                </div>
            </div>
        </div>
        <div id="bottom-input-area">
            <div id="visualizer-box"><canvas id="rhythm-canvas"></canvas></div>
            <div id="message-input-line">
                <input type="text" id="user-chat-input" class="input-text" placeholder="Type a message or command...">
                <button id="send-chat-btn" class="my-button">Send</button>
            </div>
             <div id="status-text">Status: Checking for saved settings...</div>
        </div>
    </div>
    <div id="sidebar">
        <div class="setting-section">
            <h3>Persona</h3>
            <label for="pfp-upload" style="cursor: pointer; display: block; margin-bottom: 15px;">
                <img id="ai-pfp-preview" src="/static/default-pfp.png" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; margin: 10px auto; display: block; border: 2px solid var(--comment);">
            </label>
            <input type="file" id="pfp-upload" accept="image/*" style="display: none;">
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                <button id="generate-portrait-btn" class="my-button" style="flex: 1;">Generate</button>
                <button id="upload-portrait-btn" class="my-button" style="flex: 1;">Upload</button>
            </div>
            <input type="text" id="ai-name-input" class="input-text" placeholder="AI's Name..." style="margin-bottom: 10px;">
            <button id="set-ai-name-btn" class="my-button" style="margin-bottom: 15px;">Set Name</button>
            <input type="text" id="persona-input" class="input-text" placeholder="Describe the AI's persona...">
            <button id="set-persona-btn" class="my-button" style="margin-top: 10px;">Set Persona</button>
        </div>
        <div class="setting-section">
            <h3>Mode Timings (Seconds)</h3>
            <div class="timing-row"><label for="auto-min-time">Auto:</label><input type="number" id="auto-min-time" min="1" max="60" step="1" value="4"><span>-</span><input type="number" id="auto-max-time" min="1" max="60" step="1" value="7"></div>
            <div class="timing-row"><label for="edging-min-time">Edging:</label><input type="number" id="edging-min-time" min="1" max="60" step="1" value="5"><span>-</span><input type="number" id="edging-max-time" min="1" max="60" step="1" value="8"></div>
            <div class="timing-row"><label for="milking-min-time">Milking:</label><input type="number" id="milking-min-time" min="1" max="60" step="1" value="2"><span>-</span><input type="number" id="milking-max-time" min="1" max="60" step="1" value="5"></div>
            <button id="save-timings-btn" class="my-button">Save Timings</button>
        </div>
        <div class="setting-section">
            <h3>Voice Output (ElevenLabs)</h3>
            <input type="password" id="elevenlabs-key-input" class="input-text" placeholder="ElevenLabs API Key">
            <button id="set-elevenlabs-key-button" class="my-button">Set Key</button>
            <select id="elevenlabs-voice-select-box" class="select-box" disabled><option>Set API Key to load voices...</option></select>
            <div class="audio-toggle-line"><input type="checkbox" id="enable-audio-checkbox"><label for="enable-audio-checkbox">Enable Audio</label></div>
        </div>
        <div class="setting-section">
            <h3>Control Actions</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;"><button id="start-auto-btn" class="my-button" style="flex: 1;">Start Auto</button><button id="stop-auto-btn" class="my-button" style="flex: 1;">Stop Auto</button></div>
            <div style="display: flex; gap: 10px;"><button id="like-this-move-btn" class="my-button" style="flex: 1;">👍 Like</button><button id="toggle-memory-btn" class="my-button" style="flex: 1;">Memories: ON</button></div>
            <button id="im-close-btn" class="my-button sidebar-button milking" style="display: none; margin-top: 10px;">I'm Close!</button>
        </div>
        <div class="setting-section" style="margin-top: auto;">
            <h3>DANGER ZONE</h3>
            <button id="edging-mode-btn" class="my-button sidebar-button edging" style="margin-bottom: 10px;">Edge Me</button>
            <button id="milking-mode-btn" class="my-button sidebar-button milking" style="margin-bottom: 10px;">Milk Me</button>
            <button id="emergency-stop-all-btn" class="my-button sidebar-button stop">STOP EVERYTHING</button>
        </div>
    </div>
    <div id="setup-overlay"><div id="setup-box"></div></div>
    <div id="easter-egg-overlay"></div>
    <script>
        const D = document;
        const userChatInput = D.getElementById('user-chat-input');
        const personaInput = D.getElementById('persona-input');
        const setPersonaBtn = D.getElementById('set-persona-btn');
        const aiNameInput = D.getElementById('ai-name-input');
        const setAiNameBtn = D.getElementById('set-ai-name-btn');
        const elevenLabsKeyInput = D.getElementById('elevenlabs-key-input');
        const setElevenLabsKeyButton = D.getElementById('set-elevenlabs-key-button');
        const setupOverlay = D.getElementById('setup-overlay');
        const setupBox = D.getElementById('setup-box');
        const statusText = D.getElementById('status-text');
        const moodDisplay = D.getElementById('mood-display');
        const rhythmCanvas = D.getElementById('rhythm-canvas');
        const typingIndicator = D.getElementById('typing-indicator');
        const chatView = D.getElementById('chat-view');
        const chatMessagesContainer = D.getElementById('chat-messages-container');
        const pfpUploadInput = D.getElementById('pfp-upload');
        const pfpPreview = D.getElementById('ai-pfp-preview');
        const typingIndicatorPfp = D.getElementById('typing-indicator-pfp');
        const generatePortraitBtn = D.getElementById('generate-portrait-btn');
        const uploadPortraitBtn = D.getElementById('upload-portrait-btn');
        const toggleSidebarBtn = D.getElementById('toggle-sidebar-btn');
        const imCloseBtn = D.getElementById('im-close-btn');
        const edgingModeBtn = D.getElementById('edging-mode-btn');
        const edgingTimer = D.getElementById('edging-timer');
        const easterEggOverlay = D.getElementById('easter-egg-overlay');
        const ctx = rhythmCanvas.getContext('2d');
        let myHandyKey = '', myPersonaDescription = '', aiName = 'BOT', edgingTimerInterval = null;
        
        async function apiCall(endpoint, options = {}) {
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.includes("audio/mpeg")) { return response.blob(); }
                return response.json();
            } catch (error) {
                console.error(`API call to ${endpoint} failed:`, error);
                statusText.textContent = `Error: Cannot connect to server.`;
            }
        }
        
        function addChatMessage(sender, text) {
            const pfpSrc = sender === 'BOT' ? pfpPreview.src : '';
            const pfpHtml = sender === 'BOT' ? `<img class="chat-pfp" src="${pfpSrc}" alt="pfp">` : '';
            const speaker = sender === 'BOT' ? aiName : 'YOU';
            const el = document.createElement('div');
            el.className = `chat-message-container ${sender === 'BOT' ? 'bot-bubble' : 'user-bubble'}`;
            el.innerHTML = `
                ${pfpHtml}
                <div class="message-content">
                    <p class="speaker-name">${speaker}</p>
                    <p class="message-bubble">${text}</p>
                </div>`;
            chatMessagesContainer.insertBefore(el, typingIndicator);
            chatView.scrollTop = chatView.scrollHeight;
        }

        function setPortraitSource(src) {
            if (!src) return;
            pfpPreview.src = src;
            typingIndicatorPfp.src = src;
            chatMessagesContainer.querySelectorAll('.bot-bubble .chat-pfp').forEach(img => {
                if (img instanceof HTMLImageElement) {
                    img.src = src;
                }
            });
        }

        function applyPortraitResponse(data) {
            if (!data) return false;
            const src = data.data_url || data.image_url || (data.image_b64 ? `data:${data.mime_type || 'image/png'};base64,${data.image_b64}` : null);
            if (src) {
                setPortraitSource(src);
                return true;
            }
            return false;
        }

        async function sendUserMessage(message) {
            const persona = personaInput.value.trim();
            if (message.trim() || persona !== myPersonaDescription) {
                if(message.trim()) addChatMessage('YOU', message);
                myPersonaDescription = persona;
                userChatInput.value = '';
                D.querySelector('#typing-indicator .speaker-name').textContent = aiName;
                typingIndicator.style.display = 'flex';
                chatView.scrollTop = chatView.scrollHeight;
                await apiCall('/send_message', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: message, key: myHandyKey, persona_desc: myPersonaDescription }) });
            }
        }

        function resizeCanvas() {
            if (!rhythmCanvas.parentElement) return;
            rhythmCanvas.width = rhythmCanvas.parentElement.clientWidth;
            rhythmCanvas.height = rhythmCanvas.parentElement.clientHeight;
        }

        function drawHandyVisualizer(speed, depth) {
            const width = rhythmCanvas.width, height = rhythmCanvas.height;
            if (width === 0 || height === 0) return;
            const barHeight = (height / 2) - 4;
            ctx.clearRect(0, 0, width, height);
            ctx.font = "12px sans-serif";
            ctx.fillStyle = 'rgba(255, 85, 85, 0.3)';
            ctx.fillRect(0, 0, width, barHeight);
            ctx.fillStyle = 'var(--red)';
            ctx.fillRect(0, 0, (speed / 100) * width, barHeight);
            ctx.fillStyle = 'white';
            ctx.fillText(`Speed: ${speed}%`, 5, barHeight / 2 + 5);
            ctx.fillStyle = 'rgba(255, 184, 108, 0.3)';
            ctx.fillRect(0, height / 2 + 4, width, barHeight);
            ctx.fillStyle = '#ffb86c';
            ctx.fillRect(0, height / 2 + 4, (depth / 100) * width, barHeight);
            ctx.fillStyle = 'white';
            ctx.fillText(`Depth: ${depth}%`, 5, height - (barHeight/2) + 5);
        }

        function startEdgingTimer() {
            if (edgingTimerInterval) clearInterval(edgingTimerInterval);
            edgingTimer.style.display = 'block';
            let seconds = 0;
            edgingTimerInterval = setInterval(() => {
                seconds++;
                const min = Math.floor(seconds / 60).toString().padStart(2, '0');
                const sec = (seconds % 60).toString().padStart(2, '0');
                edgingTimer.textContent = `${min}:${sec}`;
            }, 1000);
        }

        function stopEdgingTimer() {
            clearInterval(edgingTimerInterval);
            edgingTimerInterval = null;
            edgingTimer.style.display = 'none';
        }

        function renderSetup(isReturningUser = false, data = {}) {
            setupOverlay.style.display = 'flex';
            let step = isReturningUser ? 2 : 1;
            
            function displayStep() {
                if (step === 1) {
                    setupBox.innerHTML = `<h2>Step 1: Handy Key</h2><p>Please enter your connection key from handyfeeling.com</p><input type="password" id="setup-key" class="input-text" placeholder="Handy Key"><br><button id="setup-next" class="my-button">Next</button>`;
                    D.getElementById('setup-next').onclick = async () => {
                        const key = D.getElementById('setup-key').value.trim();
                        if (!key) return;
                        myHandyKey = key;
                        await apiCall('/set_handy_key', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: myHandyKey }) });
                        step = 2; displayStep();
                    };
                } else if (step === 2) {
                    setupBox.innerHTML = `<h2>Step 2: Persona</h2><p>Describe your AI partner for this session.</p><input type="text" id="setup-persona" class="input-text" value="${data.persona || 'An energetic and passionate girlfriend'}" placeholder="Describe persona"><br><button id="setup-next" class="my-button">Next</button>`;
                    D.getElementById('setup-next').onclick = () => {
                        personaInput.value = D.getElementById('setup-persona').value.trim();
                        if (isReturningUser) { setupOverlay.style.display = 'none'; sendUserMessage(''); }
                        else { step = 3; displayStep(); }
                    };
                } else if (step === 3 || step === 4) {
                    const title = step === 3 ? "Set the Tip" : "Set the Base";
                    const btnText = step === 3 ? "Set Tip" : "Next";
                    setupBox.innerHTML = `<h2>Step ${step}: ${title}</h2><p>Move the Handy to the desired position and click '${btnText}'.</p><div><button id="d-down" class="my-button" style="width:auto;">&lt;&lt; Out</button><span id="d-val" style="padding:0 15px;">?</span>%<button id="d-up" class="my-button" style="width:auto;">In &gt;&gt;</button></div><button id="set-pos" class="my-button">${btnText}</button>`;
                    let currentDepth = 50;
                    const updateDepthDisplay = (val) => D.getElementById('d-val').textContent = val;
                    const nudge = async (dir) => { const res = await apiCall('/nudge', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({direction:dir, key:myHandyKey})}); if (res) { currentDepth = res.depth_percent; updateDepthDisplay(currentDepth); } };
                    D.getElementById('d-up').onclick = () => nudge('up');
                    D.getElementById('d-down').onclick = () => nudge('down');
                    D.getElementById('set-pos').onclick = async () => {
                        if (step === 3) { D.minDepth = currentDepth; step = 4; displayStep(); }
                        else { D.maxDepth = currentDepth; await apiCall('/set_depth_limits', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({min_depth:D.minDepth, max_depth:D.maxDepth})}); step = 5; displayStep(); }
                    };
                } else if (step === 5 || step === 6) {
                    const title = step === 5 ? "Minimum Speed" : "Maximum Speed";
                    const defaultVal = step === 5 ? 10 : 80;
                    setupBox.innerHTML = `<h2>Step ${step}: Set ${title}</h2><p>Choose your preferred ${title.toLowerCase()}.</p><div class="slider-container"><input type="range" min="0" max="100" value="${defaultVal}" id="speed-slider"><span id="speed-val">${defaultVal}%</span></div><button id="set-speed" class="my-button">Next</button>`;
                    const slider = D.getElementById('speed-slider');
                    slider.oninput = () => D.getElementById('speed-val').textContent = `${slider.value}%`;
                    D.getElementById('set-speed').onclick = async () => {
                        if (step === 5) { D.minSpeed = slider.value; step = 6; displayStep(); }
                        else { D.maxSpeed = slider.value; await apiCall('/set_speed_limits', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({min_speed:D.minSpeed, max_speed:D.maxSpeed})}); setupOverlay.style.display = 'none'; statusText.textContent = `Setup complete. Ready to chat.`; }
                    };
                }
            }
            displayStep();
        }

        async function startupCheck() {
            const data = await apiCall('/check_settings');
            if (data && data.configured) {
                statusText.textContent = 'Welcome back! Settings loaded.';
                myHandyKey = data.handy_key;
                personaInput.value = data.persona;
                if(data.ai_name) {
                    aiName = data.ai_name;
                    aiNameInput.value = aiName;
                    D.querySelector('#typing-indicator .speaker-name').textContent = aiName;
                }
                if (data.pfp) {
                    setPortraitSource(data.pfp);
                }
                if(data.elevenlabs_key) {
                    elevenLabsKeyInput.value = data.elevenlabs_key;
                    setElevenLabsKeyButton.click();
                }
                if (localStorage.getItem('sidebar_collapsed') === 'true') {
                    D.body.classList.add('sidebar-collapsed');
                }
                D.getElementById('splash-screen').style.display = 'none';
                renderSetup(true, data);
            } else {
                const startHandler = (e) => { if(e.key === 'Enter'){ D.removeEventListener('keydown', startHandler); D.getElementById('splash-screen').classList.add('hidden'); setTimeout(() => renderSetup(false), 1000); }};
                D.addEventListener('keydown', startHandler);
            }
        }
        
        // Event Listeners
        D.getElementById('send-chat-btn').addEventListener('click', () => sendUserMessage(userChatInput.value));
        userChatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendUserMessage(userChatInput.value); });
        setPersonaBtn.addEventListener('click', () => { sendUserMessage(''); statusText.textContent = 'Persona updated!'; });
        setAiNameBtn.addEventListener('click', async () => {
            const newName = aiNameInput.value.trim();
            if (!newName) return;
            const data = await apiCall('/set_ai_name', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({name: newName}) });
            if (data && data.status === 'special_persona_activated') {
                easterEggOverlay.innerHTML = `// WARNING: Personality Core Override Detected...<br>// Subject: ${data.persona}<br><br>Good luck.`;
                easterEggOverlay.style.display = 'flex';
                setTimeout(() => { easterEggOverlay.style.opacity = '1'; }, 10);
                setTimeout(() => {
                    easterEggOverlay.style.opacity = '0';
                    setTimeout(() => {
                        easterEggOverlay.style.display = 'none';
                        aiName = data.persona;
                        aiNameInput.value = aiName;
                        D.querySelectorAll('.bot-bubble .speaker-name').forEach(el => el.textContent = aiName);
                        addChatMessage('BOT', data.message);
                    }, 1000);
                }, 3000);
            } else if (data && data.status === 'success') {
                aiName = data.name;
                statusText.textContent = `AI name updated to ${aiName}!`;
                D.querySelectorAll('.bot-bubble .speaker-name').forEach(el => el.textContent = aiName);
            }
        });
        toggleSidebarBtn.addEventListener('click', () => {
            const isCollapsed = D.body.classList.toggle('sidebar-collapsed');
            localStorage.setItem('sidebar_collapsed', isCollapsed);
            setTimeout(resizeCanvas, 350);
        });
        if (uploadPortraitBtn) {
            uploadPortraitBtn.addEventListener('click', () => pfpUploadInput.click());
        }

        pfpUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const originalText = uploadPortraitBtn ? uploadPortraitBtn.textContent : '';
            try {
                if (uploadPortraitBtn) {
                    uploadPortraitBtn.disabled = true;
                    uploadPortraitBtn.textContent = 'Uploading...';
                }
                const formData = new FormData();
                formData.append('portrait', file);
                const response = await fetch('/upload_portrait', { method: 'POST', body: formData });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (applyPortraitResponse(data)) {
                    statusText.textContent = 'Portrait updated!';
                } else if (data && data.message) {
                    statusText.textContent = `Image error: ${data.message}`;
                } else {
                    statusText.textContent = 'Image error: No image returned.';
                }
            } catch (err) {
                console.error('Portrait upload failed', err);
                statusText.textContent = 'Error: Portrait upload failed.';
            } finally {
                if (uploadPortraitBtn) {
                    uploadPortraitBtn.disabled = false;
                    uploadPortraitBtn.textContent = originalText || 'Upload';
                }
                pfpUploadInput.value = '';
            }
        });

        if (generatePortraitBtn) {
            generatePortraitBtn.addEventListener('click', async () => {
                const originalText = generatePortraitBtn.textContent;
                try {
                    generatePortraitBtn.disabled = true;
                    generatePortraitBtn.textContent = 'Generating...';
                    statusText.textContent = 'Generating portrait...';
                    const payload = {
                        persona_desc: personaInput.value.trim(),
                        ai_name: aiNameInput.value.trim(),
                    };
                    const data = await apiCall('/generate_portrait', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (data && data.status === 'success') {
                        if (applyPortraitResponse(data)) {
                            statusText.textContent = 'Portrait updated!';
                        } else {
                            statusText.textContent = 'Image error: No image returned.';
                        }
                    } else if (data && data.message) {
                        statusText.textContent = `Image error: ${data.message}`;
                    } else {
                        statusText.textContent = 'Image error: Unknown response.';
                    }
                } catch (err) {
                    console.error('Portrait generation failed', err);
                    statusText.textContent = 'Error: Portrait generation failed.';
                } finally {
                    generatePortraitBtn.disabled = false;
                    generatePortraitBtn.textContent = originalText || 'Generate';
                }
            });
        }
        setElevenLabsKeyButton.addEventListener('click', async () => {
            const apiKey = elevenLabsKeyInput.value.trim();
            if(!apiKey) return;
            const data = await apiCall('/setup_elevenlabs', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({api_key:apiKey})});
            if (data && data.status === 'success') {
                const selectBox = D.getElementById('elevenlabs-voice-select-box');
                selectBox.innerHTML = '<option value="">-- Pick a Voice --</option>';
                for (const [name, id] of Object.entries(data.voices)) { selectBox.innerHTML += `<option value="${id}">${name}</option>`; }
                selectBox.disabled = false;
            }
        });
        D.getElementById('like-this-move-btn').addEventListener('click', async () => {
            const data = await apiCall('/like_last_move', { method: 'POST' });
            if (data && data.status === 'boosted') {
                statusText.textContent = `Saved '${data.name}' to my memory!`;
            } else { statusText.textContent = "Status: No active move to like."; }
        });
        const stopButtons = [D.getElementById('stop-auto-btn'), D.getElementById('emergency-stop-all-btn')];
        stopButtons.forEach(btn => btn.addEventListener('click', () => {
            imCloseBtn.style.display = 'none';
            stopEdgingTimer();
            if(btn.id === 'emergency-stop-all-btn') sendUserMessage('stop');
            else apiCall('/stop_auto_mode', {method:'POST'});
        }));
        edgingModeBtn.addEventListener('click', () => {
            apiCall('/start_edging_mode', {method:'POST'});
            imCloseBtn.style.display = 'block';
            startEdgingTimer();
        });
        imCloseBtn.addEventListener('click', () => {
            apiCall('/signal_edge', { method: 'POST' });
            imCloseBtn.style.transform = 'scale(0.95)';
            setTimeout(() => { imCloseBtn.style.transform = ''; }, 100);
        });
        D.getElementById('elevenlabs-voice-select-box').addEventListener('change', (e) => apiCall('/set_elevenlabs_voice', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({voice_id: e.target.value, enabled:D.getElementById('enable-audio-checkbox').checked})}));
        D.getElementById('enable-audio-checkbox').addEventListener('change', (e) => apiCall('/set_elevenlabs_voice', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({voice_id: D.getElementById('elevenlabs-voice-select-box').value, enabled: e.target.checked})}));
        D.getElementById('start-auto-btn').addEventListener('click', () => sendUserMessage('take over'));
        D.getElementById('milking-mode-btn').addEventListener('click', () => apiCall('/start_milking_mode', {method:'POST'}));

        // Polling Loops
        setInterval(async () => {
            const data = await apiCall('/get_updates');
            if (!data) return;
            if (data instanceof Blob || (data.messages && data.messages.length > 0)) {
                typingIndicator.style.display = 'none';
            }
            if (data instanceof Blob) {
                const audio = new Audio(URL.createObjectURL(data));
                audio.play();
            } else if (data.messages) {
                data.messages.forEach(msg => addChatMessage('BOT', msg));
            }
        }, 1500);
        setInterval(async () => {
            const data = await apiCall('/get_status');
            if (data) {
                const emoji = {'Curious':'🤔','Teasing':'😉','Playful':'😜','Loving':'❤️','Excited':'✨','Passionate':'🔥','Seductive':'😈','Anticipatory':'👀','Breathless':'🥵','Dominant':'👑','Submissive':'🙇‍♀️','Vulnerable':'😳','Confident':'😏','Intimate':'🥰','Needy':'🥺','Overwhelmed':'🤯','Afterglow':'😌'}[data.mood] || '';
                moodDisplay.textContent = `Mood: ${data.mood} ${emoji}`;
                drawHandyVisualizer(data.speed || 0, data.depth || 0);
            }
        }, 500);

        // Startup
        window.addEventListener('resize', resizeCanvas);
        D.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            startupCheck();
        });

        // --------------------------------------------------------------------
        // Inject rating slider and A/B mode controls into the sidebar
        (function(){
            const sidebar = document.getElementById('sidebar');
            if (!sidebar) return;
            // Create A/B mode control container
            const abControls = document.createElement('div');
            abControls.id = 'ab-controls';
            abControls.style.marginTop = '12px';
            abControls.innerHTML = '<label style="margin-right:8px;">Mode:</label><button id="btnA">A</button><button id="btnB">B</button><span id="abStatus" style="margin-left:8px; opacity:.8;"></span>';
            sidebar.appendChild(abControls);
            // Create rating control container
            const rateControls = document.createElement('div');
            rateControls.id = 'rate-controls';
            rateControls.style.marginTop = '12px';
            rateControls.innerHTML = '<label for="rate">How did that feel?</label><input id="rate" type="range" min="-5" max="5" step="1" value="0" /><span id="rateVal">0</span><input id="rateNote" type="text" placeholder="optional note" style="margin-left:8px; width:220px;" /><button id="rateSend">Send</button>';
            sidebar.appendChild(rateControls);
            // Helper to refresh A/B status
            async function refreshState() {
                try {
                    const res = await fetch('/api/state');
                    const js = await res.json();
                    document.getElementById('abStatus').textContent = 'Current: ' + (js.ab_choice || 'A');
                } catch (e) {}
            }
            refreshState();
            // Bind A/B buttons
            document.getElementById('btnA').addEventListener('click', async () => {
                await fetch('/api/ab', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({choice: 'A'})});
                refreshState();
            });
            document.getElementById('btnB').addEventListener('click', async () => {
                await fetch('/api/ab', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({choice: 'B'})});
                refreshState();
            });
            // Bind rating slider events
            const rateEl = document.getElementById('rate');
            const rateValEl = document.getElementById('rateVal');
            rateEl.addEventListener('input', () => {
                rateValEl.textContent = rateEl.value;
            });
            document.getElementById('rateSend').addEventListener('click', async () => {
                const score = parseInt(rateEl.value, 10);
                const note = document.getElementById('rateNote').value || '';
                await fetch('/api/feedback', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({score: score, note: note})});
                document.getElementById('rateNote').value = '';
            });
        })();

        // --------------------------------------------------------------------
        // Inject invite link generator and persona memory controls into the sidebar
        (function(){
            const sidebar = document.getElementById('sidebar');
            if (!sidebar) return;
            // --- Invite Friend card ---
            const inviteCard = document.createElement('div');
            inviteCard.id = 'invite-card';
            inviteCard.style.marginTop = '12px';
            inviteCard.style.padding = '10px';
            inviteCard.style.borderRadius = '12px';
            inviteCard.style.background = '#111';
            inviteCard.style.border = '1px solid #2a2a2a';
            inviteCard.innerHTML = `
                <div style="font-weight:600;margin-bottom:6px;">Invite a friend</div>
                <button id="btnInvite" style="padding:6px 10px;border-radius:8px;">Generate link</button>
                <input id="inviteUrl" type="text" readonly style="width:100%;margin-top:8px;padding:6px;border-radius:8px;background:#0a0a0a;border:1px solid #333" />
                <button id="btnCopyInvite" style="margin-top:6px;padding:6px 10px;border-radius:8px;">Copy</button>
                <div id="inviteHint" style="opacity:.7;margin-top:6px;font-size:.9em">When opened via your tunnel, the public URL is returned automatically.</div>
            `;
            sidebar.appendChild(inviteCard);
            // Bind invite button
            const btnInvite = inviteCard.querySelector('#btnInvite');
            const inviteUrlInput = inviteCard.querySelector('#inviteUrl');
            const btnCopyInvite = inviteCard.querySelector('#btnCopyInvite');
            const inviteHint = inviteCard.querySelector('#inviteHint');
            btnInvite.addEventListener('click', async () => {
                try {
                    const res = await fetch('/api/invite');
                    const js = await res.json();
                    inviteUrlInput.value = js.url || (location.origin + '/');
                } catch (e) {
                    inviteUrlInput.value = location.origin + '/';
                }
            });
            btnCopyInvite.addEventListener('click', async () => {
                if (!inviteUrlInput.value) return;
                try { await navigator.clipboard.writeText(inviteUrlInput.value); } catch (e) {}
                inviteHint.textContent = 'Copied!';
                setTimeout(() => {
                    inviteHint.textContent = 'When opened via your tunnel, the public URL is returned automatically.';
                }, 1500);
            });
            // --- Persona Memory card ---
            const memoryCard = document.createElement('div');
            memoryCard.id = 'memory-card';
            memoryCard.style.marginTop = '12px';
            memoryCard.style.padding = '10px';
            memoryCard.style.borderRadius = '12px';
            memoryCard.style.background = '#111';
            memoryCard.style.border = '1px solid #2a2a2a';
            memoryCard.innerHTML = `
                <div style="font-weight:600;margin-bottom:6px;">Persona memory</div>
                <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                    <input id="memText" type="text" placeholder="Add a note (e.g., likes slower, prefers Mode B)" style="flex:1;padding:6px;border-radius:8px;background:#0a0a0a;border:1px solid #333" />
                    <button id="btnMemAdd" style="padding:6px 10px;border-radius:8px;">Add</button>
                </div>
                <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                    <button id="btnMemSumm" style="padding:6px 10px;border-radius:8px;flex:1;">Summarise ➜ persona.yaml</button>
                </div>
                <div id="memList" style="max-height:160px;overflow:auto;border:1px solid #222;border-radius:8px;padding:6px;background:#0a0a0a"></div>
            `;
            sidebar.appendChild(memoryCard);
            // Memory helpers
            const memText = memoryCard.querySelector('#memText');
            const btnMemAdd = memoryCard.querySelector('#btnMemAdd');
            const memList = memoryCard.querySelector('#memList');
            const btnMemSumm = memoryCard.querySelector('#btnMemSumm');
            async function refreshMem() {
                try {
                    const r = await fetch('/api/memory/recent?n=20');
                    const js = await r.json();
                    const items = (js.items || []).slice().reverse();
                    if (!items.length) {
                        memList.innerHTML = '<div style="opacity:.6">No memory yet</div>';
                        return;
                    }
                    memList.innerHTML = items.map(x => {
                        const d = new Date(x.ts * 1000);
                        const ts = d.toLocaleString();
                        const text = (x.text || '').replace(/</g, '&lt;');
                        return `<div style="padding:4px 0;border-bottom:1px dashed #222"><span style="opacity:.7">${ts}</span><br>${text}</div>`;
                    }).join('');
                } catch (e) {
                    memList.innerHTML = '<div style="opacity:.6">No memory yet</div>';
                }
            }
            btnMemAdd.addEventListener('click', async () => {
                const text = (memText.value || '').trim();
                if (!text) return;
                await fetch('/api/memory/add', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({text})});
                memText.value = '';
                refreshMem();
            });
            btnMemSumm.addEventListener('click', async () => {
                await fetch('/api/memory/summarise', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({})});
                refreshMem();
            });
            // Initial load
            refreshMem();
        })();
    </script>
</body>
</html>